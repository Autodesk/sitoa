/************************************************************************************************************************************
Copyright 2017 Autodesk, Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. 
You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, 
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
See the License for the specific language governing permissions and limitations under the License.
************************************************************************************************************************************/

#pragma once

#include "common/Group.h"
#include "loader/ICE.h"
#include "loader/Lights.h"
#include "loader/PathTranslator.h"
#include "loader/ShaderDef.h"
#include "renderer/AtNodeLookup.h"
#include "renderer/DisplayDriver.h"
#include "renderer/RendererOptions.h"

#include <xsi_renderer.h>
#include <xsi_renderercontext.h>

#define FRAME_NOT_INITIALIZED_VALUE -1234567.89

// Simple class to get a unique int every time it Gets called.
// Having to face shaders with instance values, we can't simply use the xsi shader fullname
// to name the corresponding Arnold node, because there can be more than one Arnold node
// generated by the same xsi shader at a given frame time. So, we add the unique int
// at the end of the shaders' name
//
class CUniqueIdGenerator
{
private:
   unsigned int m_id;
public:
   CUniqueIdGenerator() : m_id(0)
   {}

   void Reset()
   {
      m_id = 0;
   }

   unsigned int Get()
   {
      return ++m_id;
   }
};


class CObjectsAdded
{
public:
   CRefArray m_objects;
   CObjectsAdded()
   {
   }
   ~CObjectsAdded()
   {
      m_objects.Clear();
   } 
   void Add(CRef in_ref);
   CRefArray Get();
   void Clear();
};


// This class to cache all the exported nodes
//
class CNodeMap
{
private:
   AtNodeLookupMap  m_map;

public:
   CNodeMap()
   {}

   ~CNodeMap()
   {
      m_map.clear();
   }

   // Push a node into the exported objects map
   void PushExportedNode(ProjectItem in_item, double in_frame, AtNode *in_node);
   // Get a node from the exported objects map
   AtNode* GetExportedNode(CString &in_objectName, double in_frame);
   // Get a node from the exported objects map
   AtNode* GetExportedNode(ProjectItem in_item, double in_frame);
   // Erase a member from the exported nodes map
   void EraseExportedNode(CString &in_name, double in_frame);
   // Erase a member pointing to a given node from the exported nodes map
   void EraseExportedNode(AtNode *in_node);
   // Update all the shapes in the scene, when in flythrough mode
   void FlythroughUpdate();
   // Destroy the map
   void Clear();
   // debug
   void LogExportedNodes();
};


enum eRenderStatus
{
    eRenderStatus_Uninitialized,
    eRenderStatus_Started,
    eRenderStatus_Finished
};

// Class that will Render & maintain updated (IPR) Arnold Scene
class CRenderInstance
{
public:
   CRenderInstance();
   ~CRenderInstance();
   // Custom Callback from XSI that indicantes a Export Process
   CStatus Export();

   CStatus InitializeRender(CRef &in_ctxt);
   // Destroy Arnold Scene
   void DestroyScene(bool in_flushTextures);
   // Interrupts the Render
   void InterruptRender();
   // Flush loaded Textures
   void FlushTextures();

   // Event callback of a value changed
   CStatus OnValueChange(CRef &in_ctxt);
   // Event callback of an object added
   CStatus OnObjectAdded(CRef &in_ctxt);
   // Event callback of an object removed
   CStatus OnObjectRemoved(CRef &in_ctxt);

   // Returns Renderer CRef from RenderContext
   CRef GetRendererRef();

   Camera GetRenderCamera();
      
   DisplayDriver* GetDisplayDriver();

   double GetFrame() const;
   void   SetFrame(const double in_frame);
   double GetFlythroughFrame() const;
   void   SetFlythroughFrame(const double in_frame);

   const CString& GetRenderType() const;

   void SetRenderType(const CString& in_renderType);
   
   bool InterruptRenderSignal();
   void SetInterruptRenderSignal(bool in_value);
  
   eRenderStatus RenderStatus();
   void SetRenderStatus(const eRenderStatus in_status);

   CStatus Process();
   CStatus ProcessPass();
   CStatus ProcessRegion();

   // handles to the map of all the exported nodes, groups, lights, shaders. missing shaders
   CNodeMap&          NodeMap();   
   CGroupMap&         GroupMap();
   CLightMap&         LightMap();
   CShaderMap&        ShaderMap();
   CMissingShaderMap& MissingShaderMap();
   CShaderDefSet&     ShaderDefSet();

   CSearchPath& GetTexturesSearchPath();
   CSearchPath& GetProceduralsSearchPath();
   CSearchPath& GetPluginsSearchPath();

   CObjectsAdded m_objectsAdded;
   CRenderOptions m_renderOptions;
   // the log file
   ofstream m_logFile;

   // Get a unique id, for assigning different names to duplicated shaders
   int GetUniqueId();
   // Open the log file
   void OpenLogFile(const CString &in_path);
   // Close the log file, if it's open
   void CloseLogFile();

private:

   enum eUpdateType
   {
      eUpdateType_Undefined,
      eUpdateType_Camera,
      eUpdateType_Light,
      eUpdateType_LightKinematics,
      eUpdateType_Shader,
      eUpdateType_ImageClip,
      eUpdateType_RenderOptions,
      eUpdateType_RenderOptionsTexture,
      eUpdateType_IncompatibleIPR,
      eUpdateType_ArnoldParameters,
      eUpdateType_PassShaderStack,
      eUpdateType_ArnoldVisibility,
      eUpdateType_ArnoldSidedness,
      eUpdateType_ArnoldMatte,
      eUpdateType_Material,
      eUpdateType_Group,
      eUpdateType_ShapeKinematics,
      eUpdateType_WrappingSettings,
      eUpdateType_ObjectUnhidden
   };

   // Create the directories for all the output filenames of all the buffers
   bool OutputDirectoryExists();

   int RenderProgressiveScene(int displayArea);

   // Detect what type of Update we have to do for the given Reference
   CRef GetUpdateType(const CRef &in_ref, eUpdateType &out_updateType);
   // Update Arnold Scene with the data of the object 
   CStatus UpdateScene(const CRef &in_ref, eUpdateType in_updateType);
   // Calculates the region we have to Render & updates them into Arnold parameters
   unsigned int UpdateRenderRegion(unsigned int in_width, unsigned int in_height);

   // Trigger Render Events when the render starts
   CStatus TriggerBeginRenderEvent();
   // Trigger Render Events when the render stops
   CStatus TriggerEndRenderEvent(bool in_skipped = false);
   // Display Driver member
   DisplayDriver     m_displayDriver;   
   // Actual Render Context
   RendererContext   m_renderContext;
  
   // Actual Render Type (Region, Pass, Shaderball)
   CString           m_renderType;

   unsigned int      m_renderWidth;
   unsigned int      m_renderHeight;

   CStringArray      m_outputImgNames;
   // the 3 search paths
   CSearchPath       m_texturesSearchPath;
   CSearchPath       m_proceduralsSearchPath;
   CSearchPath       m_pluginsSearchPath;

   Pass              m_pass;

   bool              m_interruptRender;
   AtMutex           m_interruptRenderBarrier;
   AtMutex           m_destroySceneBarrier;

   eRenderStatus     m_renderStatus;
   AtMutex           m_renderStatusBarrier;

   Property          m_renderOptionsProperty;
   double            m_frame;
   double            m_flythrough_frame; // the frame at which the flythrough mode was enabled, if any

   // the exported node, group, light, shader, missing shaders maps
   CNodeMap          m_nodeMap;
   CGroupMap         m_groupMap;
   CLightMap         m_lightMap;
   CShaderMap        m_shaderMap;
   CMissingShaderMap m_missingShaderMap;
   // unique id generator, for assigning different names to duplicated nodes
   CUniqueIdGenerator m_uniqueIdGenerator;
   // class for the auto shader definition
   CShaderDefSet      m_shaderDefSet;

   int DoRender(const AtRenderMode in_mode = AI_RENDER_MODE_CAMERA);
};

